if &compatible
  set nocompatible
endif

set encoding=utf-8
scriptencoding utf-8

" Personal config {{{
let s:personal=expand('~/.personal/vimrc')
if filereadable(s:personal)
  exec "source" s:personal
endif
" }}}

set guioptions=egM

if !has('packages')
  runtime bundle/pathogen/autoload/pathogen.vim
  execute pathogen#infect()
endif

" Mouse {{{
if has('mouse')
  set mouse=a
endif
" }}}

" Updates {{{
" Update faster (CursorHold event)
set updatetime=250
" Don't update while running macros
set lazyredraw
" }}}

" Backspace {{{
" Allow backspacking over everything in insert mode
set backspace=indent,eol,start
" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
" Revert with ":iunmap <C-U>".
inoremap <C-U> <C-G>u<C-U>
" }}}

" Search options {{{
" Ignore case in /? searches
set ignorecase
" Unless capitals are present
set smartcase
" Highlight searches
set hlsearch
" Do incremental searching when it's possible to timeout
if has('reltime')
  set incsearch
endif
" }}}

" Time out for key codes {{{
set ttimeout
" Wait up to 100ms after <Esc> for special key
set ttimeoutlen=100
" But 3000ms (3s) for mappings
set timeoutlen=3000
" }}}

" Persistence {{{
" Keep 10000 lines of command history
set history=10000
" Keep marks
set viminfo+=f1
if exists("&viminfofile")
  set viminfofile=$HOME/.viminfo
endif
set undofile undodir=~/.undo
if !isdirectory(expand(&undodir))
  call mkdir(expand(&undodir), "p")
endif
" }}}

" Completion {{{
" Complete from dictionary if spell on
set complete+=kspell
" Automatically insert longest common prefix
set completeopt+=longest
" Make matching handle case better
set infercase
if has('autocmd')
  augroup vimrc_completion
    au!
    " Add omnicompletion using syntax if a file doesn't already have it
    au FileType * if &omnifunc == "" |
          \ setlocal omnifunc=syntaxcomplete#Complete |
          \ endif
    " Close the preview window after Insert-mode completion.
    let g:exceptions = ['gitcommit']
    if exists('##CompleteDone')
      autocmd CompleteDone *
            \ if index(g:exceptions, &filetype) < 0 | silent! pclose | endif
    endif
  augroup END
endif
" Display completion matches in the status line
set wildmenu
set wildmode=longest,full
set wildignore+=*.a,*.o
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
set wildignore+=.DS_Store,.git,.hg,.svn
set wildignore+=*~,*.swp,*.tmp
set wildignore+=*.aux,*.bbl,*.blg,*.dvi,*.log,*.pdf,*.out,*.bcf,*.run.xml
" }}}

" Text wrapping and width {{{
set textwidth=80
set colorcolumn=+0
" Wrap lines that are too long (off by default)
set nowrap
" Show wrapped lines with a marker in front
let &showbreak='└>'
" Break at word boundaries
set linebreak
" Allow movements Left and Right to move over wrapped lines
set whichwrap=b,s,<,>,[,]
" }}}

" Indent settings: 4 spaces (unless overriden by ftplugin) {{{
" A Tab character has length 8 (always)
set tabstop=8
" Use spaces when pressing Tab in insert
set expandtab
" Used for indent-features ('<<' and the like)
set shiftwidth=4
" Round < and the like to nearest shiftwidth
set shiftround
" Backspace over 4 spaces if possible
set softtabstop=4
" Use 'autoindent', which mostly does what you want and stays out of your way
set autoindent
" }}}

" Line numbers {{{
" Display rel numbers by default
set relativenumber
if has('autocmd')
  augroup vimrc_cmdwin_num
    au!
    autocmd CmdwinEnter * setlocal nonumber norelativenumber
  augroup END
endif
" }}}

" Display context {{{
if has("patch-7.4.2109")
  " Show @@@ in the last line if it is truncated
  set display=truncate
else
  set display=lastline
endif
" Show a few lines of context around the cursor. Note that this makes the text
" scroll if you mouse-click near the start or end of the window
set scrolloff=5
" Display certain whitespace characters
set list listchars=tab:»\ ,trail:·,nbsp:\|,precedes:<,extends:>
set conceallevel=2 concealcursor=nc
command Conceal set conceallevel=2
command Reveal set conceallevel=0
" }}}

" Status {{{
" Display incomplete commands
set showcmd
" Show what mode we're in
set showmode
" Always display status line
set laststatus=2

function! Head() abort
  let l:head = substitute(simplify(expand('%:h')), $HOME, '~', '')
  if l:head != ''
    let l:head .= '/'
  endif
  return l:head
endfunction

function! AleCountTotal() abort
  if exists(':ALELint')
    let l:bufnr = bufnr('%')
    let l:ale_count = ale#statusline#Count(l:bufnr)
    let l:total = ale_count['total']
    if l:total > 0
      return printf('Lint: %d', l:total)
    endif
  endif
  return ''
endfunction

function! s:status_line(verbosity) abort
  set statusline=
  if a:verbosity ==# 'long'
    set statusline+=%([%{Head()}%1*%t%*]%)
  elseif a:verbosity ==# 'short'
    set statusline+=%([%1*%t%*]%)
  endif
  set statusline+=%5*%(%m%r%w%h%)%*
  set statusline+=%(%y%)
  set statusline+=%([%{exists('*FugitiveHead')?FugitiveHead():''}]%)
  set statusline+=%=%<
  if a:verbosity ==# 'long'
    set statusline+=%([%3*%l%*/%LL,%3*%c%*,%p%%]%)
    set statusline+=%([%{exists('*wordcount')?wordcount().words.'W':''}]%)
    set statusline+=%([%{&ff}\|%{(&fenc==''?&enc:&fenc).((exists('+bomb')&&&bomb)?'\|bom':'')}]%)
  elseif a:verbosity ==# 'short'
    set statusline+=%([%3*%l,%c%*]%)
  endif
  set statusline+=%(%a%)
  set statusline+=%4*%([%{AleCountTotal()}]%)%*
  set statusline+=%(%{exists('*ObsessionStatus')?ObsessionStatus():''}%)
endfunction

command SLLong call s:status_line('long')
command SLShort call s:status_line('short')

SLShort

function! s:set_statusline_colors_to_dracula() abort
  " Override statusline
  hi clear StatusLine
  hi clear StatusLineNc
  hi link StatusLine DraculaComment
  hi link StatusLineNC DraculaSubtle

  hi link User1 DraculaGreen
  hi link User2 DraculaPurple
  hi link User3 DraculaCyan
  hi link User4 DraculaRed
  hi link User5 DraculaOrange
endfunction

if has('autocmd')
  augroup status_colors_dracula
    au!
    autocmd ColorScheme dracula call s:set_statusline_colors_to_dracula()
  augroup END
endif
" }}}

" Syntax specific {{{
" Switch syntax highlighting on when the terminal has colors or when using the
" GUI (which always has colors).
if &t_Co > 2 || has("gui_running")
  if ! exists("g:syntax_on")
    syntax enable
  endif
  " Use bash as default shell highlighter (cf :h ft-sh-syntax)
  let g:is_bash = 1
  " Langs for markdown blocks
  let g:markdown_fenced_languages = [
        \ 'bash=sh',
        \ 'python',
        \ 'c',
        \ 'vim',
        \ 'clojure',
        \ ]
  " Do NOT highlight javadoc specially: it is distracting
  let java_ignore_javadoc = 1
  " default tex flavor
  let g:tex_flavor = 'latex'
  " don't spell check
  let g:tex_comment_nospell = 1
  let g:clojure_align_multiline_strings = 1
  let g:clojure_maxlines = 50
endif
" }}}

" Filetype {{{
if has('autocmd')
  filetype plugin indent on
  " Use proper scaladoc indentation
  " Found in (uncomment "gcc" and type "<LocalLeader>el")
  " split +/scala_scaladoc_indent $VIMRUNTIME/indent/scala.vim
  let g:scala_scaladoc_indent = 1
  " no indent for applescripts that don't need it
  let g:applescript_default_indent = 0
  augroup vimrc_bash_fc
    au!
    " bash's edit-and-execute-command (which probably leans on the fc mechanism)
    " produces lots of temp files that we don't need undo files for; they are
    " clutter
    "
    " see the following link for filename specifics
    " http://git.savannah.gnu.org/cgit/bash.git/tree/builtins/fc.def?h=bash-4.4-rc2#n394
    au BufNewFile,BufReadPre *bash-fc* setlocal noundofile
  augroup END
endif
" }}}
